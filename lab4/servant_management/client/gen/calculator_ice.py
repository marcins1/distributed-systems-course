# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.10
#
# <auto-generated>
#
# Generated from file `calculator.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module CalculatorApp
_M_CalculatorApp = Ice.openModule('CalculatorApp')
__name__ = 'CalculatorApp'

_M_CalculatorApp._t_BasicCalculator = IcePy.defineValue('::CalculatorApp::BasicCalculator', Ice.Value, -1, (), False, True, None, ())

if 'BasicCalculatorPrx' not in _M_CalculatorApp.__dict__:
    _M_CalculatorApp.BasicCalculatorPrx = Ice.createTempClass()
    class BasicCalculatorPrx(Ice.ObjectPrx):

        def add(self, a, b, context=None):
            return _M_CalculatorApp.BasicCalculator._op_add.invoke(self, ((a, b), context))

        def addAsync(self, a, b, context=None):
            return _M_CalculatorApp.BasicCalculator._op_add.invokeAsync(self, ((a, b), context))

        def begin_add(self, a, b, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.BasicCalculator._op_add.begin(self, ((a, b), _response, _ex, _sent, context))

        def end_add(self, _r):
            return _M_CalculatorApp.BasicCalculator._op_add.end(self, _r)

        def subtract(self, a, b, context=None):
            return _M_CalculatorApp.BasicCalculator._op_subtract.invoke(self, ((a, b), context))

        def subtractAsync(self, a, b, context=None):
            return _M_CalculatorApp.BasicCalculator._op_subtract.invokeAsync(self, ((a, b), context))

        def begin_subtract(self, a, b, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.BasicCalculator._op_subtract.begin(self, ((a, b), _response, _ex, _sent, context))

        def end_subtract(self, _r):
            return _M_CalculatorApp.BasicCalculator._op_subtract.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_CalculatorApp.BasicCalculatorPrx.ice_checkedCast(proxy, '::CalculatorApp::BasicCalculator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_CalculatorApp.BasicCalculatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::BasicCalculator'
    _M_CalculatorApp._t_BasicCalculatorPrx = IcePy.defineProxy('::CalculatorApp::BasicCalculator', BasicCalculatorPrx)

    _M_CalculatorApp.BasicCalculatorPrx = BasicCalculatorPrx
    del BasicCalculatorPrx

    _M_CalculatorApp.BasicCalculator = Ice.createTempClass()
    class BasicCalculator(Ice.Object):

        def ice_ids(self, current=None):
            return ('::CalculatorApp::BasicCalculator', '::Ice::Object')

        def ice_id(self, current=None):
            return '::CalculatorApp::BasicCalculator'

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::BasicCalculator'

        def add(self, a, b, current=None):
            raise NotImplementedError("servant method 'add' not implemented")

        def subtract(self, a, b, current=None):
            raise NotImplementedError("servant method 'subtract' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_CalculatorApp._t_BasicCalculatorDisp)

        __repr__ = __str__

    _M_CalculatorApp._t_BasicCalculatorDisp = IcePy.defineClass('::CalculatorApp::BasicCalculator', BasicCalculator, (), None, ())
    BasicCalculator._ice_type = _M_CalculatorApp._t_BasicCalculatorDisp

    BasicCalculator._op_add = IcePy.Operation('add', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), ())
    BasicCalculator._op_subtract = IcePy.Operation('subtract', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), ())

    _M_CalculatorApp.BasicCalculator = BasicCalculator
    del BasicCalculator

_M_CalculatorApp._t_ExtendedCalculator = IcePy.defineValue('::CalculatorApp::ExtendedCalculator', Ice.Value, -1, (), False, True, None, ())

if 'ExtendedCalculatorPrx' not in _M_CalculatorApp.__dict__:
    _M_CalculatorApp.ExtendedCalculatorPrx = Ice.createTempClass()
    class ExtendedCalculatorPrx(Ice.ObjectPrx):

        def multiply(self, a, b, context=None):
            return _M_CalculatorApp.ExtendedCalculator._op_multiply.invoke(self, ((a, b), context))

        def multiplyAsync(self, a, b, context=None):
            return _M_CalculatorApp.ExtendedCalculator._op_multiply.invokeAsync(self, ((a, b), context))

        def begin_multiply(self, a, b, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.ExtendedCalculator._op_multiply.begin(self, ((a, b), _response, _ex, _sent, context))

        def end_multiply(self, _r):
            return _M_CalculatorApp.ExtendedCalculator._op_multiply.end(self, _r)

        def divide(self, a, b, context=None):
            return _M_CalculatorApp.ExtendedCalculator._op_divide.invoke(self, ((a, b), context))

        def divideAsync(self, a, b, context=None):
            return _M_CalculatorApp.ExtendedCalculator._op_divide.invokeAsync(self, ((a, b), context))

        def begin_divide(self, a, b, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.ExtendedCalculator._op_divide.begin(self, ((a, b), _response, _ex, _sent, context))

        def end_divide(self, _r):
            return _M_CalculatorApp.ExtendedCalculator._op_divide.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_CalculatorApp.ExtendedCalculatorPrx.ice_checkedCast(proxy, '::CalculatorApp::ExtendedCalculator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_CalculatorApp.ExtendedCalculatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::ExtendedCalculator'
    _M_CalculatorApp._t_ExtendedCalculatorPrx = IcePy.defineProxy('::CalculatorApp::ExtendedCalculator', ExtendedCalculatorPrx)

    _M_CalculatorApp.ExtendedCalculatorPrx = ExtendedCalculatorPrx
    del ExtendedCalculatorPrx

    _M_CalculatorApp.ExtendedCalculator = Ice.createTempClass()
    class ExtendedCalculator(Ice.Object):

        def ice_ids(self, current=None):
            return ('::CalculatorApp::ExtendedCalculator', '::Ice::Object')

        def ice_id(self, current=None):
            return '::CalculatorApp::ExtendedCalculator'

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::ExtendedCalculator'

        def multiply(self, a, b, current=None):
            raise NotImplementedError("servant method 'multiply' not implemented")

        def divide(self, a, b, current=None):
            raise NotImplementedError("servant method 'divide' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_CalculatorApp._t_ExtendedCalculatorDisp)

        __repr__ = __str__

    _M_CalculatorApp._t_ExtendedCalculatorDisp = IcePy.defineClass('::CalculatorApp::ExtendedCalculator', ExtendedCalculator, (), None, ())
    ExtendedCalculator._ice_type = _M_CalculatorApp._t_ExtendedCalculatorDisp

    ExtendedCalculator._op_multiply = IcePy.Operation('multiply', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), ())
    ExtendedCalculator._op_divide = IcePy.Operation('divide', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0), ((), IcePy._t_int, False, 0)), (), ((), IcePy._t_int, False, 0), ())

    _M_CalculatorApp.ExtendedCalculator = ExtendedCalculator
    del ExtendedCalculator

_M_CalculatorApp._t_ScientificCalculator = IcePy.defineValue('::CalculatorApp::ScientificCalculator', Ice.Value, -1, (), False, True, None, ())

if 'ScientificCalculatorPrx' not in _M_CalculatorApp.__dict__:
    _M_CalculatorApp.ScientificCalculatorPrx = Ice.createTempClass()
    class ScientificCalculatorPrx(Ice.ObjectPrx):

        def squareRoot(self, a, context=None):
            return _M_CalculatorApp.ScientificCalculator._op_squareRoot.invoke(self, ((a, ), context))

        def squareRootAsync(self, a, context=None):
            return _M_CalculatorApp.ScientificCalculator._op_squareRoot.invokeAsync(self, ((a, ), context))

        def begin_squareRoot(self, a, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.ScientificCalculator._op_squareRoot.begin(self, ((a, ), _response, _ex, _sent, context))

        def end_squareRoot(self, _r):
            return _M_CalculatorApp.ScientificCalculator._op_squareRoot.end(self, _r)

        def power(self, base, exponent, context=None):
            return _M_CalculatorApp.ScientificCalculator._op_power.invoke(self, ((base, exponent), context))

        def powerAsync(self, base, exponent, context=None):
            return _M_CalculatorApp.ScientificCalculator._op_power.invokeAsync(self, ((base, exponent), context))

        def begin_power(self, base, exponent, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.ScientificCalculator._op_power.begin(self, ((base, exponent), _response, _ex, _sent, context))

        def end_power(self, _r):
            return _M_CalculatorApp.ScientificCalculator._op_power.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_CalculatorApp.ScientificCalculatorPrx.ice_checkedCast(proxy, '::CalculatorApp::ScientificCalculator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_CalculatorApp.ScientificCalculatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::ScientificCalculator'
    _M_CalculatorApp._t_ScientificCalculatorPrx = IcePy.defineProxy('::CalculatorApp::ScientificCalculator', ScientificCalculatorPrx)

    _M_CalculatorApp.ScientificCalculatorPrx = ScientificCalculatorPrx
    del ScientificCalculatorPrx

    _M_CalculatorApp.ScientificCalculator = Ice.createTempClass()
    class ScientificCalculator(Ice.Object):

        def ice_ids(self, current=None):
            return ('::CalculatorApp::ScientificCalculator', '::Ice::Object')

        def ice_id(self, current=None):
            return '::CalculatorApp::ScientificCalculator'

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::ScientificCalculator'

        def squareRoot(self, a, current=None):
            raise NotImplementedError("servant method 'squareRoot' not implemented")

        def power(self, base, exponent, current=None):
            raise NotImplementedError("servant method 'power' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_CalculatorApp._t_ScientificCalculatorDisp)

        __repr__ = __str__

    _M_CalculatorApp._t_ScientificCalculatorDisp = IcePy.defineClass('::CalculatorApp::ScientificCalculator', ScientificCalculator, (), None, ())
    ScientificCalculator._ice_type = _M_CalculatorApp._t_ScientificCalculatorDisp

    ScientificCalculator._op_squareRoot = IcePy.Operation('squareRoot', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), ((), IcePy._t_double, False, 0), ())
    ScientificCalculator._op_power = IcePy.Operation('power', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0), ((), IcePy._t_double, False, 0)), (), ((), IcePy._t_double, False, 0), ())

    _M_CalculatorApp.ScientificCalculator = ScientificCalculator
    del ScientificCalculator

_M_CalculatorApp._t_TrygonometricCalculator = IcePy.defineValue('::CalculatorApp::TrygonometricCalculator', Ice.Value, -1, (), False, True, None, ())

if 'TrygonometricCalculatorPrx' not in _M_CalculatorApp.__dict__:
    _M_CalculatorApp.TrygonometricCalculatorPrx = Ice.createTempClass()
    class TrygonometricCalculatorPrx(Ice.ObjectPrx):

        def sin(self, a, context=None):
            return _M_CalculatorApp.TrygonometricCalculator._op_sin.invoke(self, ((a, ), context))

        def sinAsync(self, a, context=None):
            return _M_CalculatorApp.TrygonometricCalculator._op_sin.invokeAsync(self, ((a, ), context))

        def begin_sin(self, a, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.TrygonometricCalculator._op_sin.begin(self, ((a, ), _response, _ex, _sent, context))

        def end_sin(self, _r):
            return _M_CalculatorApp.TrygonometricCalculator._op_sin.end(self, _r)

        def cos(self, a, context=None):
            return _M_CalculatorApp.TrygonometricCalculator._op_cos.invoke(self, ((a, ), context))

        def cosAsync(self, a, context=None):
            return _M_CalculatorApp.TrygonometricCalculator._op_cos.invokeAsync(self, ((a, ), context))

        def begin_cos(self, a, _response=None, _ex=None, _sent=None, context=None):
            return _M_CalculatorApp.TrygonometricCalculator._op_cos.begin(self, ((a, ), _response, _ex, _sent, context))

        def end_cos(self, _r):
            return _M_CalculatorApp.TrygonometricCalculator._op_cos.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_CalculatorApp.TrygonometricCalculatorPrx.ice_checkedCast(proxy, '::CalculatorApp::TrygonometricCalculator', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_CalculatorApp.TrygonometricCalculatorPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::TrygonometricCalculator'
    _M_CalculatorApp._t_TrygonometricCalculatorPrx = IcePy.defineProxy('::CalculatorApp::TrygonometricCalculator', TrygonometricCalculatorPrx)

    _M_CalculatorApp.TrygonometricCalculatorPrx = TrygonometricCalculatorPrx
    del TrygonometricCalculatorPrx

    _M_CalculatorApp.TrygonometricCalculator = Ice.createTempClass()
    class TrygonometricCalculator(Ice.Object):

        def ice_ids(self, current=None):
            return ('::CalculatorApp::TrygonometricCalculator', '::Ice::Object')

        def ice_id(self, current=None):
            return '::CalculatorApp::TrygonometricCalculator'

        @staticmethod
        def ice_staticId():
            return '::CalculatorApp::TrygonometricCalculator'

        def sin(self, a, current=None):
            raise NotImplementedError("servant method 'sin' not implemented")

        def cos(self, a, current=None):
            raise NotImplementedError("servant method 'cos' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_CalculatorApp._t_TrygonometricCalculatorDisp)

        __repr__ = __str__

    _M_CalculatorApp._t_TrygonometricCalculatorDisp = IcePy.defineClass('::CalculatorApp::TrygonometricCalculator', TrygonometricCalculator, (), None, ())
    TrygonometricCalculator._ice_type = _M_CalculatorApp._t_TrygonometricCalculatorDisp

    TrygonometricCalculator._op_sin = IcePy.Operation('sin', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), ((), IcePy._t_double, False, 0), ())
    TrygonometricCalculator._op_cos = IcePy.Operation('cos', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_double, False, 0),), (), ((), IcePy._t_double, False, 0), ())

    _M_CalculatorApp.TrygonometricCalculator = TrygonometricCalculator
    del TrygonometricCalculator

# End of module CalculatorApp
